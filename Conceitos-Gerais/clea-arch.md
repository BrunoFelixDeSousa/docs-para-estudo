# Guia Definitivo: Clean Architecture aplicada ao Quarkus

## 1. O que √© Clean Architecture? (Conceito Fundamental)

Imagine sua aplica√ß√£o como uma **cebola** üßÖ. Cada camada tem sua responsabilidade e as camadas internas n√£o conhecem as externas.

**Analogia simples**: Pense numa empresa:
- **CEO** (Entities): Define as regras fundamentais do neg√≥cio
- **Gerentes** (Use Cases): Organizam e coordenam as a√ß√µes
- **Supervisores** (Adapters): Fazem a ponte entre departamentos
- **Funcion√°rios** (Frameworks): Executam tarefas espec√≠ficas

### Principais Objetivos
- **Independ√™ncia de frameworks**: Trocar Spring por Quarkus sem quebrar regras de neg√≥cio
- **Testabilidade**: Testar l√≥gica sem banco de dados
- **Desacoplamento**: Mudan√ßas numa camada n√£o afetam outras
- **Manuten√ß√£o**: C√≥digo organizado e previs√≠vel

### As 4 Camadas em C√≠rculos Conc√™ntricos

```mermaid
graph TD
    subgraph "Frameworks & Drivers"
        DB[(Database)]
        API[External APIs]
        UI[REST Controllers]
    end
    
    subgraph "Interface Adapters"
        GW[Gateways]
        CTRL[Controllers]
        PRES[Presenters]
    end
    
    subgraph "Application Business Rules"
        UC[Use Cases]
    end
    
    subgraph "Enterprise Business Rules"
        ENT[Entities]
    end
    
    UI --> CTRL
    CTRL --> UC
    UC --> ENT
    UC --> GW
    GW --> DB
    GW --> API
```

**Regra Fundamental**: As depend√™ncias sempre apontam para dentro. A camada interna nunca conhece a externa.

## 2. Comparando com Outras Arquiteturas

| Arquitetura | Caracter√≠sticas | Quando Usar |
|------------|----------------|-------------|
| **MVC** | Controller ‚Üí Service ‚Üí Repository | Projetos simples, prototipagem |
| **Hexagonal** | Ports & Adapters | Quando precisa de m√∫ltiplos adapters |
| **Onion** | Camadas conc√™ntricas | Similar √† Clean, menos formal |
| **Clean** | Use Cases expl√≠citos, regras r√≠gidas | Projetos complexos, longo prazo |

**Por que Clean Architecture?**
- Mais **disciplinada** que MVC
- Mais **estruturada** que Hexagonal
- **Use Cases** expl√≠citos (diferente da Onion)

## 3. Estrutura de Pacotes no Quarkus

```
src/main/java/com/example/
‚îú‚îÄ‚îÄ domain/                    # üéØ Regras de Neg√≥cio Puras
‚îÇ   ‚îú‚îÄ‚îÄ entities/             # Objetos fundamentais
‚îÇ   ‚îî‚îÄ‚îÄ gateways/            # Contratos (interfaces)
‚îú‚îÄ‚îÄ application/              # üé™ Orquestra√ß√£o
‚îÇ   ‚îî‚îÄ‚îÄ usecases/            # Casos de uso espec√≠ficos
‚îú‚îÄ‚îÄ infrastructure/          # üîß Implementa√ß√µes t√©cnicas
‚îÇ   ‚îú‚îÄ‚îÄ repositories/        # Persist√™ncia
‚îÇ   ‚îî‚îÄ‚îÄ external/           # APIs externas
‚îî‚îÄ‚îÄ interfaces/              # üåê Pontos de entrada
    ‚îî‚îÄ‚îÄ rest/               # Controllers REST
```

## 4. Exemplo Pr√°tico: Sistema de Pedidos

Vamos construir um sistema de pedidos passo a passo, da camada mais interna para a externa.

### 4.1 Entidade (Cora√ß√£o do Sistema)

```java
// domain/entities/Order.java
public class Order {
    private final String id;
    private final String customerId;
    private final BigDecimal total;
    private final LocalDateTime createdAt;

    public Order(String customerId, BigDecimal total) {
        // üõ°Ô∏è Regras de neg√≥cio SEMPRE na entidade
        if (total == null || total.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Total deve ser positivo");
        }
        if (customerId == null || customerId.trim().isEmpty()) {
            throw new IllegalArgumentException("Cliente √© obrigat√≥rio");
        }
        
        this.id = UUID.randomUUID().toString();
        this.customerId = customerId;
        this.total = total;
        this.createdAt = LocalDateTime.now();
    }
    
    // Construtor para reconstru√ß√£o (vindo do banco)
    public Order(String id, String customerId, BigDecimal total, LocalDateTime createdAt) {
        this.id = id;
        this.customerId = customerId;
        this.total = total;
        this.createdAt = createdAt;
    }

    // üí∞ L√≥gica de neg√≥cio: calcular desconto
    public BigDecimal calculateDiscountedTotal(BigDecimal discountPercent) {
        if (discountPercent.compareTo(BigDecimal.ZERO) < 0 || 
            discountPercent.compareTo(new BigDecimal("100")) > 0) {
            throw new IllegalArgumentException("Desconto deve estar entre 0% e 100%");
        }
        
        BigDecimal discount = total.multiply(discountPercent).divide(new BigDecimal("100"));
        return total.subtract(discount);
    }

    // Getters
    public String getId() { return id; }
    public String getCustomerId() { return customerId; }
    public BigDecimal getTotal() { return total; }
    public LocalDateTime getCreatedAt() { return createdAt; }
}
```

### 4.2 Gateway (Contrato/Interface)

```java
// domain/gateways/OrderRepository.java
public interface OrderRepository {
    Order save(Order order);
    Optional<Order> findById(String id);
    List<Order> findByCustomerId(String customerId);
}

// domain/gateways/NotificationGateway.java
public interface NotificationGateway {
    void sendOrderConfirmation(Order order);
}
```

### 4.3 Caso de Uso (Orquestrador)

```java
// application/usecases/CreateOrderUseCase.java
@ApplicationScoped
public class CreateOrderUseCase {
    private final OrderRepository orderRepository;
    private final NotificationGateway notificationGateway;

    public CreateOrderUseCase(OrderRepository orderRepository, 
                             NotificationGateway notificationGateway) {
        this.orderRepository = orderRepository;
        this.notificationGateway = notificationGateway;
    }

    public Order execute(String customerId, BigDecimal total) {
        // 1. Criar pedido (regras na entidade)
        Order order = new Order(customerId, total);
        
        // 2. Salvar
        Order savedOrder = orderRepository.save(order);
        
        // 3. Notificar (orquestra√ß√£o)
        notificationGateway.sendOrderConfirmation(savedOrder);
        
        return savedOrder;
    }
}
```

### 4.4 Implementa√ß√£o da Infraestrutura

```java
// infrastructure/repositories/OrderEntity.java
@Entity
@Table(name = "orders")
public class OrderEntity extends PanacheEntity {
    public String customerId;
    public BigDecimal total;
    public LocalDateTime createdAt;

    // Convers√£o para Domain
    public Order toDomain() {
        return new Order(
            this.id.toString(),
            this.customerId,
            this.total,
            this.createdAt
        );
    }

    // Convers√£o do Domain
    public static OrderEntity fromDomain(Order order) {
        OrderEntity entity = new OrderEntity();
        entity.customerId = order.getCustomerId();
        entity.total = order.getTotal();
        entity.createdAt = order.getCreatedAt();
        return entity;
    }
}

// infrastructure/repositories/OrderRepositoryImpl.java
@ApplicationScoped
public class OrderRepositoryImpl implements OrderRepository {

    @Override
    public Order save(Order order) {
        OrderEntity entity = OrderEntity.fromDomain(order);
        entity.persist();
        
        // Retorna com ID gerado
        return new Order(
            entity.id.toString(),
            order.getCustomerId(),
            order.getTotal(),
            order.getCreatedAt()
        );
    }

    @Override
    public Optional<Order> findById(String id) {
        return OrderEntity.findByIdOptional(Long.valueOf(id))
                .map(entity -> ((OrderEntity) entity).toDomain());
    }

    @Override
    public List<Order> findByCustomerId(String customerId) {
        return OrderEntity.list("customerId", customerId)
                .stream()
                .map(entity -> ((OrderEntity) entity).toDomain())
                .toList();
    }
}
```

### 4.5 Controller (Interface Externa)

```java
// interfaces/rest/OrderResource.java
@Path("/orders")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class OrderResource {

    private final CreateOrderUseCase createOrderUseCase;

    public OrderResource(CreateOrderUseCase createOrderUseCase) {
        this.createOrderUseCase = createOrderUseCase;
    }

    @POST
    public Response createOrder(@Valid CreateOrderRequest request) {
        try {
            Order order = createOrderUseCase.execute(
                request.customerId, 
                request.total
            );
            
            return Response.status(201)
                    .entity(OrderResponse.fromDomain(order))
                    .build();
                    
        } catch (IllegalArgumentException e) {
            return Response.status(400)
                    .entity(Map.of("error", e.getMessage()))
                    .build();
        }
    }
}

// DTOs
public class CreateOrderRequest {
    @NotNull
    public String customerId;
    
    @NotNull
    @DecimalMin("0.01")
    public BigDecimal total;
}

public class OrderResponse {
    public String id;
    public String customerId;
    public BigDecimal total;
    public String createdAt;

    public static OrderResponse fromDomain(Order order) {
        OrderResponse response = new OrderResponse();
        response.id = order.getId();
        response.customerId = order.getCustomerId();
        response.total = order.getTotal();
        response.createdAt = order.getCreatedAt().toString();
        return response;
    }
}
```

## 5. Testabilidade: O Grande Benef√≠cio

### Teste da Entidade (Regras de Neg√≥cio)

```java
class OrderTest {

    @Test
    void shouldCreateValidOrder() {
        Order order = new Order("CUST123", new BigDecimal("100.00"));
        
        assertNotNull(order.getId());
        assertEquals("CUST123", order.getCustomerId());
        assertEquals(new BigDecimal("100.00"), order.getTotal());
    }

    @Test
    void shouldRejectNegativeTotal() {
        assertThrows(IllegalArgumentException.class, () -> 
            new Order("CUST123", new BigDecimal("-10.00"))
        );
    }

    @Test
    void shouldCalculateDiscount() {
        Order order = new Order("CUST123", new BigDecimal("100.00"));
        BigDecimal discounted = order.calculateDiscountedTotal(new BigDecimal("10"));
        
        assertEquals(new BigDecimal("90.00"), discounted);
    }
}
```

### Teste do Caso de Uso (Sem Infraestrutura)

```java
@ExtendWith(MockitoExtension.class)
class CreateOrderUseCaseTest {

    @Mock
    private OrderRepository orderRepository;
    
    @Mock
    private NotificationGateway notificationGateway;

    private CreateOrderUseCase useCase;

    @BeforeEach
    void setUp() {
        useCase = new CreateOrderUseCase(orderRepository, notificationGateway);
    }

    @Test
    void shouldCreateOrderSuccessfully() {
        // Given
        String customerId = "CUST123";
        BigDecimal total = new BigDecimal("100.00");
        
        when(orderRepository.save(any(Order.class)))
            .thenAnswer(invocation -> {
                Order order = invocation.getArgument(0);
                // Simula ID gerado pelo banco
                return new Order("ORDER123", order.getCustomerId(), 
                               order.getTotal(), order.getCreatedAt());
            });

        // When
        Order result = useCase.execute(customerId, total);

        // Then
        assertEquals("ORDER123", result.getId());
        assertEquals(customerId, result.getCustomerId());
        assertEquals(total, result.getTotal());
        
        verify(orderRepository).save(any(Order.class));
        verify(notificationGateway).sendOrderConfirmation(result);
    }
}
```

## 6. Benef√≠cios da Clean Architecture com Quarkus

### ‚úÖ Independ√™ncia de Frameworks
```java
// Posso trocar Panache por JPA puro, MongoDB, etc.
// Apenas mudo a implementa√ß√£o do OrderRepositoryImpl
```

### ‚úÖ Testabilidade M√°xima
```java
// Testo regras de neg√≥cio sem banco
// Testo casos de uso com mocks
// Testo controllers com TestRestTemplate
```

### ‚úÖ Flexibilidade
```java
// Posso ter m√∫ltiplos adapters:
// - OrderRepositoryJpaImpl
// - OrderRepositoryMongoImpl  
// - OrderRepositoryRedisImpl
```

### ‚úÖ Evolu√ß√£o Gradual
```java
// Come√ßar simples e evoluir:
// 1. CRUD b√°sico
// 2. Adicionar valida√ß√µes
// 3. Integrar APIs externas
// 4. Adicionar eventos
```

## 7. Projeto Pr√°tico: Implementa√ß√£o Completa

### Estrutura Final do Projeto

```
order-service/
‚îú‚îÄ‚îÄ src/main/java/com/example/orders/
‚îÇ   ‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ entities/Order.java
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ gateways/OrderRepository.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ gateways/NotificationGateway.java
‚îÇ   ‚îú‚îÄ‚îÄ application/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ usecases/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CreateOrderUseCase.java
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ FindOrderUseCase.java
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ ListOrdersByCustomerUseCase.java
‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ repositories/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ OrderEntity.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ OrderRepositoryImpl.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ notifications/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ EmailNotificationGateway.java
‚îÇ   ‚îî‚îÄ‚îÄ interfaces/
‚îÇ       ‚îî‚îÄ‚îÄ rest/
‚îÇ           ‚îú‚îÄ‚îÄ OrderResource.java
‚îÇ           ‚îú‚îÄ‚îÄ requests/CreateOrderRequest.java
‚îÇ           ‚îî‚îÄ‚îÄ responses/OrderResponse.java
‚îú‚îÄ‚îÄ src/test/java/
‚îî‚îÄ‚îÄ pom.xml
```

### Configura√ß√£o do pom.xml

```xml
<dependencies>
    <dependency>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-resteasy-reactive-jackson</artifactId>
    </dependency>
    <dependency>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-hibernate-orm-panache</artifactId>
    </dependency>
    <dependency>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-jdbc-postgresql</artifactId>
    </dependency>
    <dependency>
        <groupId>io.quarkus</groupId>
        <artifactId>quarkus-hibernate-validator</artifactId>
    </dependency>
</dependencies>
```

## 8. Pr√≥ximos Passos: Projetos Evolutivos

### üöÄ N√≠vel Iniciante: CRUD Completo
- Implementar todas opera√ß√µes CRUD
- Adicionar valida√ß√µes robustas
- Testes unit√°rios completos

### üöÄ N√≠vel Intermedi√°rio: Integra√ß√µes
- Gateway para API externa de clientes
- Sistema de notifica√ß√µes por email
- Implementar diferentes reposit√≥rios (PostgreSQL + Redis)

### üöÄ N√≠vel Avan√ßado: Microservi√ßo Completo
- Integra√ß√£o com Apache Kafka
- Observabilidade com Micrometer + Prometheus
- Deploy com containers
- Circuit Breaker para resili√™ncia

## 9. Diagrama de Sequ√™ncia: Fluxo Completo

Vamos visualizar como funciona o fluxo de cria√ß√£o de um pedido atrav√©s de todas as camadas:

### 9.1 Fluxo Principal: Cria√ß√£o de Pedido

```mermaid
sequenceDiagram
    participant Client as üì± Cliente
    participant Controller as üåê OrderResource<br/>(Interface)
    participant UseCase as üé™ CreateOrderUseCase<br/>(Application)
    participant Entity as üéØ Order<br/>(Domain)
    participant Repository as üîß OrderRepositoryImpl<br/>(Infrastructure)
    participant Database as üóÑÔ∏è PostgreSQL
    participant Notification as üìß NotificationGateway<br/>(Infrastructure)
    participant EmailAPI as üìÆ Email Service

    Note over Client, EmailAPI: üöÄ In√≠cio do Fluxo de Cria√ß√£o

    Client->>+Controller: POST /orders<br/>{"customerId": "CUST123", "total": 100.00}
    
    Note over Controller: üõ°Ô∏è Valida√ß√£o de entrada<br/>(Bean Validation)
    
    Controller->>+UseCase: execute("CUST123", 100.00)
    
    Note over UseCase: üé≠ Orquestra√ß√£o do caso de uso
    
    UseCase->>+Entity: new Order("CUST123", 100.00)
    
    Note over Entity: ‚öñÔ∏è Aplica√ß√£o das regras de neg√≥cio<br/>- Validar total > 0<br/>- Validar customerId n√£o nulo<br/>- Gerar ID √∫nico<br/>- Definir timestamp
    
    alt üö´ Regras de neg√≥cio violadas
        Entity-->>UseCase: IllegalArgumentException
        UseCase-->>Controller: Exception
        Controller-->>Client: 400 Bad Request<br/>{"error": "Total deve ser positivo"}
    else ‚úÖ Regras v√°lidas
        Entity-->>-UseCase: Order criada com sucesso
        
        Note over UseCase: üíæ Persistir o pedido
        
        UseCase->>+Repository: save(order)
        Repository->>+Database: INSERT INTO orders...
        Database-->>-Repository: ID gerado (ex: 1001)
        Repository-->>-UseCase: Order com ID atualizado
        
        Note over UseCase: üì® Enviar notifica√ß√£o
        
        UseCase->>+Notification: sendOrderConfirmation(order)
        Notification->>+EmailAPI: POST /send-email<br/>{"to": "customer@email.com", "subject": "Pedido Criado"}
        EmailAPI-->>-Notification: Email enviado
        Notification-->>-UseCase: Notifica√ß√£o enviada
        
        UseCase-->>-Controller: Order completa
        
        Note over Controller: üîÑ Convers√£o Domain ‚Üí DTO
        
        Controller-->>-Client: 201 Created<br/>{"id": "1001", "customerId": "CUST123", "total": 100.00}
    end

    Note over Client, EmailAPI: ‚úÖ Fluxo Conclu√≠do com Sucesso
```

### 9.2 Fluxo de Busca de Pedido

```mermaid
sequenceDiagram
    participant Client as üì± Cliente
    participant Controller as üåê OrderResource
    participant UseCase as üé™ FindOrderUseCase
    participant Repository as üîß OrderRepositoryImpl
    participant Database as üóÑÔ∏è PostgreSQL

    Client->>+Controller: GET /orders/1001
    Controller->>+UseCase: execute("1001")
    UseCase->>+Repository: findById("1001")
    Repository->>+Database: SELECT * FROM orders WHERE id = 1001
    
    alt üö´ Pedido n√£o encontrado
        Database-->>Repository: Resultado vazio
        Repository-->>UseCase: Optional.empty()
        UseCase-->>Controller: OrderNotFoundException
        Controller-->>Client: 404 Not Found
    else ‚úÖ Pedido encontrado
        Database-->>-Repository: Dados do pedido
        Repository-->>-UseCase: Optional<Order>
        UseCase-->>-Controller: Order
        Controller-->>-Client: 200 OK<br/>{"id": "1001", "customerId": "CUST123"}
    end
```

### 9.3 Fluxo com Falha de Infraestrutura

```mermaid
sequenceDiagram
    participant Client as üì± Cliente
    participant Controller as üåê OrderResource
    participant UseCase as üé™ CreateOrderUseCase
    participant Entity as üéØ Order
    participant Repository as üîß OrderRepositoryImpl
    participant Database as üóÑÔ∏è PostgreSQL
    participant Notification as üìß NotificationGateway

    Client->>+Controller: POST /orders
    Controller->>+UseCase: execute(dados)
    UseCase->>+Entity: new Order(dados)
    Entity-->>-UseCase: Order v√°lida
    
    UseCase->>+Repository: save(order)
    Repository->>+Database: INSERT INTO orders...
    
    Note over Database: üí• Falha de conex√£o<br/>ou constraint violation
    
    Database-->>-Repository: SQLException
    Repository-->>-UseCase: DatabaseException
    
    Note over UseCase: üîÑ Rollback autom√°tico<br/>(Transa√ß√£o Quarkus)
    
    UseCase-->>-Controller: DatabaseException
    Controller-->>-Client: 500 Internal Server Error<br/>{"error": "Erro interno do servidor"}
    
    Note over Client: üìù Log detalhado no servidor<br/>Cliente recebe erro gen√©rico
```

### 9.4 An√°lise dos Benef√≠cios Arquiteturais

**üéØ Separa√ß√£o Clara de Responsabilidades**
- **Controller**: Apenas convers√£o HTTP ‚Üî Domain
- **UseCase**: Orquestra√ß√£o e regras de aplica√ß√£o
- **Entity**: Regras de neg√≥cio puras
- **Repository**: Apenas persist√™ncia

**üõ°Ô∏è Prote√ß√£o das Regras de Neg√≥cio**
- Valida√ß√µes na Entity s√£o inviol√°veis
- UseCase n√£o conhece detalhes HTTP ou banco
- Mudan√ßas na infraestrutura n√£o afetam o dom√≠nio

**üß™ Facilidade de Testes**
- **Entity**: Teste unit√°rio puro (sem mocks)
- **UseCase**: Mock apenas dos gateways
- **Controller**: Teste de integra√ß√£o com TestRestTemplate

**üîÑ Flexibilidade de Evolu√ß√£o**
- Trocar PostgreSQL por MongoDB: apenas Repository
- Adicionar cache: decorator no Repository
- Mudar notifica√ß√£o: apenas NotificationGateway

## Conclus√£o

A Clean Architecture com Quarkus oferece:

1. **C√≥digo Limpo**: Cada camada tem sua responsabilidade
2. **Flexibilidade**: Troque tecnologias sem dor
3. **Testabilidade**: Teste tudo, at√© regras complexas
4. **Manutenibilidade**: Evolua o c√≥digo com confian√ßa
5. **Performance**: Quarkus + arquitetura limpa = velocidade

**Lembre-se**: Comece simples, aplique os conceitos gradualmente e sempre mantenha as regras de depend√™ncia: **de fora para dentro, nunca o contr√°rio**.